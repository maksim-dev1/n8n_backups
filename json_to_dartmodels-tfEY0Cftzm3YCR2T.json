{"createdAt":"2025-07-09T04:21:57.208Z","updatedAt":"2025-07-11T12:06:09.000Z","id":"tfEY0Cftzm3YCR2T","name":"Json_to_DartModels","active":true,"isArchived":false,"nodes":[{"parameters":{"updates":["message"],"additionalFields":{}},"type":"n8n-nodes-base.telegramTrigger","typeVersion":1.2,"position":[-1120,-320],"id":"ef993ff5-3068-4e60-8ec4-0f62fdfac59f","name":"Telegram Trigger","webhookId":"2d8cc69d-2715-4e16-8803-6f16621e73a4","notesInFlow":false,"credentials":{"telegramApi":{"id":"Xz6gXqtWh7SDH76M","name":"Telegram account"}}},{"parameters":{"promptType":"define","text":"={{ $json.data }}","options":{"systemMessage":"Преобразуй входящий json в модели данных dto и entity для dart по этим примерам\n\n@freezed\nsealed class SearchAddressDTO with _$SearchAddressDTO {\n  const factory SearchAddressDTO({\n    required String address,\n    required double latitude,\n    required double longitude,\n  }) = _SearchAddressDTO;\n\n  factory SearchAddressDTO.fromJson(Map<String, Object?> json) =>\n      _$SearchAddressDTOFromJson(json);\n}\n\n@freezed\nsealed class SearchAddressEntity with _$SearchAddressEntity {\n  const factory SearchAddressEntity({\n    required String address,\n    required double latitude,\n    required double longitude,\n  }) = _SearchAddressEntity;\n}\n"}},"type":"@n8n/n8n-nodes-langchain.agent","typeVersion":2,"position":[140,-280],"id":"1246aed8-a30c-41ae-b010-4b36be2f574e","name":"AI Agent"},{"parameters":{"chatId":"={{ $json.chat_id }}","text":"={{ $json.text }}","additionalFields":{}},"type":"n8n-nodes-base.telegram","typeVersion":1.2,"position":[1100,-280],"id":"1168c9fe-217b-4941-9974-b2db1befb5e9","name":"Telegram","webhookId":"efd849fa-2448-4afe-9349-6bac5a3844eb","credentials":{"telegramApi":{"id":"Xz6gXqtWh7SDH76M","name":"Telegram account"}}},{"parameters":{"rules":{"values":[{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"leftValue":"={{ $json.message.document }}","rightValue":"","operator":{"type":"object","operation":"notEmpty","singleValue":true},"id":"1aaf9d7b-cd98-449d-a107-167c70567611"}],"combinator":"and"},"renameOutput":true,"outputKey":"document isNotEmpty"},{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"e35741e7-92da-4913-89c8-839ed19e0a59","leftValue":"={{ $json.message.text }}","rightValue":"","operator":{"type":"string","operation":"notEmpty","singleValue":true}}],"combinator":"and"},"renameOutput":true,"outputKey":"text isNotEmpty"}]},"options":{}},"type":"n8n-nodes-base.switch","typeVersion":3.2,"position":[-900,-320],"id":"a1c92184-1be2-45a3-b184-39b4554b917e","name":"Switch"},{"parameters":{"resource":"file","fileId":"={{ $json.message.document.file_id }}"},"type":"n8n-nodes-base.telegram","typeVersion":1.2,"position":[-560,-480],"id":"ec049638-f071-4e85-ba70-14b59ae5a050","name":"Telegram1","webhookId":"d86bc34e-3f08-4085-9d71-dd89a135485d","credentials":{"telegramApi":{"id":"Xz6gXqtWh7SDH76M","name":"Telegram account"}}},{"parameters":{"operation":"fromJson","options":{}},"type":"n8n-nodes-base.extractFromFile","typeVersion":1,"position":[-360,-480],"id":"750e5e6e-d757-4e45-a0e5-68da6cba978a","name":"Extract from File"},{"parameters":{"jsCode":"const obj = JSON.parse($input.first().json.message.text);\n\nreturn obj;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-460,-160],"id":"3cbf427c-d811-438b-a9ec-630ede5e9cb5","name":"Code"},{"parameters":{"modelName":"models/gemini-2.5-flash","options":{}},"type":"@n8n/n8n-nodes-langchain.lmChatGoogleGemini","typeVersion":1,"position":[120,-60],"id":"6dc5ee8c-3c1c-4c73-b6db-b9fc8f4fb8ef","name":"Google Gemini Chat Model","credentials":{"googlePalmApi":{"id":"2v8o2u6caNwpzQBd","name":"Google Gemini(PaLM) Api account"}}},{"parameters":{"aggregate":"aggregateAllItemData","options":{}},"type":"n8n-nodes-base.aggregate","typeVersion":1,"position":[-100,-280],"id":"36e6f61d-6111-4c5e-a29d-7cae0d4e5efd","name":"Aggregate"},{"parameters":{"jsCode":"// FunctionItem: semanticChunker.js\n\n// Получаем весь сгенерированный AI‑текст в Markdown\nconst fullText = $input.first().json.output;    // замените на своё поле\nconst chatId   = $('Telegram Trigger').first().json.message.chat.id;        // и своё поле chat_id\n\n// Максимальный размер одного сообщения (оставляем небольшой запас)\nconst MAX_LEN = 4000;\n\n// 1. Разделяем на части: кодовые блоки и обычный текст\nconst parts = [];\nconst regexCodeBlock = /```[\\w]*[\\s\\S]*?```/g;\nlet lastIndex = 0;\nlet match;\n\nwhile (match = regexCodeBlock.exec(fullText)) {\n  if (match.index > lastIndex) {\n    parts.push({ type: 'text', content: fullText.slice(lastIndex, match.index) });\n  }\n  parts.push({ type: 'code', content: match[0] });\n  lastIndex = regexCodeBlock.lastIndex;\n}\nif (lastIndex < fullText.length) {\n  parts.push({ type: 'text', content: fullText.slice(lastIndex) });\n}\n\n// 2. Функция для разбивки больших кодовых блоков, сохраняя language‑таг\nfunction splitCodeBlock(block) {\n  // Определяем opener: например \"```dart\" или просто \"```\"\n  const openerMatch = block.match(/^```(\\w*)/);\n  const opener = openerMatch\n    ? `\\`\\`\\`${openerMatch[1]}\\n`\n    : \"```dart\\n\";\n  const closer = \"\\n```\";\n\n  // Убираем открывающий и закрывающий теги\n  const inner = block.slice(block.indexOf('\\n') + 1, block.lastIndexOf('```'));\n  // Разрезаем по двойному переносу или окончанию секции\n  const rawSections = inner.split(/\\n\\}\\s*\\n/).map((sec, i, arr) => {\n    if (i < arr.length - 1) return sec + \"\\n}\";\n    return sec;\n  });\n\n  return rawSections\n    .map(s => s.trim())\n    .filter(s => s)\n    .map(s => opener + s + closer);\n}\n\n// 3. Собираем окончательные сегменты\nconst segments = [];\nparts.forEach(p => {\n  if (p.type === 'text') {\n    p.content.split(/(\\r?\\n\\r?\\n)/).forEach(seg => {\n      if (seg.trim()) segments.push(seg);\n    });\n  } else {\n    if (p.content.length <= MAX_LEN) {\n      // Если в исходном блоке уже был ```dart, он сохранится\n      // Иначе мы обернём его как dart\n      if (/^```[\\w]+/.test(p.content)) {\n        segments.push(p.content);\n      } else {\n        segments.push(p.content.replace(/^```/, '```dart'));\n      }\n    } else {\n      segments.push(...splitCodeBlock(p.content));\n    }\n  }\n});\n\n// 4. Аккумулируем сегменты в чанки по лимиту\nconst chunks = [];\nlet current = \"\";\n\nsegments.forEach(seg => {\n  if ((current + seg).length <= MAX_LEN) {\n    current += seg;\n  } else {\n    if (current) chunks.push(current);\n    if (seg.length > MAX_LEN) {\n      chunks.push(seg);\n      current = \"\";\n    } else {\n      current = seg;\n    }\n  }\n});\nif (current) chunks.push(current);\n\n// 5. Возвращаем массив сообщений\nreturn chunks.map(textPart => ({\n  json: {\n    chat_id: chatId,\n    text: textPart\n  }\n}));"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[720,-280],"id":"d90cb611-a845-4760-9331-a13700a41991","name":"Code1"}],"connections":{"Telegram Trigger":{"main":[[{"node":"Switch","type":"main","index":0}]]},"AI Agent":{"main":[[{"node":"Code1","type":"main","index":0}]]},"Telegram":{"main":[[]]},"Switch":{"main":[[{"node":"Telegram1","type":"main","index":0}],[{"node":"Code","type":"main","index":0}]]},"Telegram1":{"main":[[{"node":"Extract from File","type":"main","index":0}]]},"Extract from File":{"main":[[{"node":"Aggregate","type":"main","index":0}]]},"Code":{"main":[[{"node":"Aggregate","type":"main","index":0}]]},"Google Gemini Chat Model":{"ai_languageModel":[[{"node":"AI Agent","type":"ai_languageModel","index":0}]]},"Aggregate":{"main":[[{"node":"AI Agent","type":"main","index":0}]]},"Code1":{"main":[[{"node":"Telegram","type":"main","index":0}]]}},"settings":{"executionOrder":"v1","saveDataErrorExecution":"none","saveDataSuccessExecution":"none","saveExecutionProgress":true,"callerPolicy":"workflowsFromSameOwner","saveManualExecutions":false,"errorWorkflow":"bcQQ6FgxYk3RibuS"},"staticData":null,"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"9b55bf9e-80d2-4c5d-899a-48b07b4de2bc","triggerCount":1,"tags":[]}